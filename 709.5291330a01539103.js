"use strict";(self.webpackChunktokemonworld=self.webpackChunktokemonworld||[]).push([[709],{37709:(zn,ye,Dt)=>{Dt.r(ye),Dt.d(ye,{encodeToCurve:()=>Pn,hashToCurve:()=>Mn,schnorr:()=>Zn,secp256k1:()=>Lt,secp256k1_hasher:()=>we});var R=Dt(51014);function nn(t,n,e){return t&n^~t&e}function rn(t,n,e){return t&n^t&e^n&e}class Ee extends R.Vw{constructor(n,e,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(n),this.view=(0,R.O8)(this.buffer)}update(n){(0,R.CC)(this),n=(0,R.ZJ)(n),(0,R.DO)(n);const{view:e,buffer:r,blockLen:s}=this,o=n.length;for(let c=0;c<o;){const f=Math.min(s-this.pos,o-c);if(f===s){const i=(0,R.O8)(n);for(;s<=o-c;c+=s)this.process(i,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){(0,R.CC)(this),(0,R.Ht)(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:c}=this;e[c++]=128,(0,R.uH)(this.buffer.subarray(c)),this.padOffset>s-c&&(this.process(r,0),c=0);for(let l=c;l<s;l++)e[l]=0;(function en(t,n,e,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(n,e,r);const s=BigInt(32),o=BigInt(4294967295),c=Number(e>>s&o),f=Number(e&o),a=r?0:4;t.setUint32(n+(r?4:0),c,r),t.setUint32(n+a,f,r)})(r,s-8,BigInt(8*this.length),o),this.process(r,0);const f=(0,R.O8)(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=i/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)f.setUint32(4*l,u[l],o)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:c,pos:f}=this;return n.destroyed=c,n.finished=o,n.length=s,n.pos=f,s%e&&n.buffer.set(r),n}clone(){return this._cloneInto()}}const ot=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var O=Dt(11999);const sn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ct=new Uint32Array(64);class pe extends Ee{constructor(n=32){super(64,n,8,!1),this.A=0|ot[0],this.B=0|ot[1],this.C=0|ot[2],this.D=0|ot[3],this.E=0|ot[4],this.F=0|ot[5],this.G=0|ot[6],this.H=0|ot[7]}get(){const{A:n,B:e,C:r,D:s,E:o,F:c,G:f,H:i}=this;return[n,e,r,s,o,c,f,i]}set(n,e,r,s,o,c,f,i){this.A=0|n,this.B=0|e,this.C=0|r,this.D=0|s,this.E=0|o,this.F=0|c,this.G=0|f,this.H=0|i}process(n,e){for(let l=0;l<16;l++,e+=4)ct[l]=n.getUint32(e,!1);for(let l=16;l<64;l++){const b=ct[l-15],y=ct[l-2],p=(0,R.Ow)(b,7)^(0,R.Ow)(b,18)^b>>>3,h=(0,R.Ow)(y,17)^(0,R.Ow)(y,19)^y>>>10;ct[l]=h+ct[l-7]+p+ct[l-16]|0}let{A:r,B:s,C:o,D:c,E:f,F:i,G:a,H:u}=this;for(let l=0;l<64;l++){const y=u+((0,R.Ow)(f,6)^(0,R.Ow)(f,11)^(0,R.Ow)(f,25))+nn(f,i,a)+sn[l]+ct[l]|0,h=((0,R.Ow)(r,2)^(0,R.Ow)(r,13)^(0,R.Ow)(r,22))+rn(r,s,o)|0;u=a,a=i,i=f,f=c+y|0,c=o,o=s,s=r,r=y+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,c=c+this.D|0,f=f+this.E|0,i=i+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,s,o,c,f,i,a,u)}roundClean(){(0,R.uH)(ct)}destroy(){this.set(0,0,0,0,0,0,0,0),(0,R.uH)(this.buffer)}}O.lD(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t)));const Mt=(0,R.qj)(()=>new pe);class ve extends R.Vw{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,(0,R.sd)(n);const r=(0,R.ZJ)(e);if(this.iHash=n.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=n.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),(0,R.uH)(o)}update(n){return(0,R.CC)(this),this.iHash.update(n),this}digestInto(n){(0,R.CC)(this),(0,R.DO)(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:c,outputLen:f}=this;return n.finished=s,n.destroyed=o,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ae=(t,n,e)=>new ve(t,n).update(e).digest();Ae.create=(t,n)=>new ve(t,n);const Pt=BigInt(0),At=BigInt(1);function St(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function lt(t){if(!St(t))throw new Error("Uint8Array expected")}function _t(t,n){if("boolean"!=typeof n)throw new Error(t+" boolean expected, got "+n)}function Ht(t){const n=t.toString(16);return 1&n.length?"0"+n:n}function Se(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Pt:BigInt("0x"+t)}const _e="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,fn=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function It(t){if(lt(t),_e)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=fn[t[e]];return n}function He(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function Ot(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(_e)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const c=He(t.charCodeAt(o)),f=He(t.charCodeAt(o+1));if(void 0===c||void 0===f)throw new Error('hex string expected, got non-hex character "'+(t[o]+t[o+1])+'" at index '+o);r[s]=16*c+f}return r}function et(t){return Se(It(t))}function Ie(t){return lt(t),Se(It(Uint8Array.from(t).reverse()))}function xt(t,n){return Ot(t.toString(16).padStart(2*n,"0"))}function Oe(t,n){return xt(t,n).reverse()}function z(t,n,e){let r;if("string"==typeof n)try{r=Ot(n)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else{if(!St(n))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(n)}const s=r.length;if("number"==typeof e&&s!==e)throw new Error(t+" of length "+e+" expected, got "+s);return r}function J(...t){let n=0;for(let r=0;r<t.length;r++){const s=t[r];lt(s),n+=s.length}const e=new Uint8Array(n);for(let r=0,s=0;r<t.length;r++){const o=t[r];e.set(o,s),s+=o.length}return e}function Jt(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const $t=t=>"bigint"==typeof t&&Pt<=t;function qt(t,n,e){return $t(t)&&$t(n)&&$t(e)&&n<=t&&t<e}function wt(t,n,e,r){if(!qt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}const zt=t=>(At<<BigInt(t))-At,Ft=t=>new Uint8Array(t),qe=t=>Uint8Array.from(t),dn={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||St(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function Ct(t,n,e={}){const r=(s,o,c)=>{const f=dn[o];if("function"!=typeof f)throw new Error("invalid validator function");const i=t[s];if(!(c&&void 0===i||f(i,t)))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+i)};for(const[s,o]of Object.entries(n))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return t}function Ce(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(void 0!==s)return s;const o=t(e,...r);return n.set(e,o),o}}const Y=BigInt(0),D=BigInt(1),gt=BigInt(2),un=BigInt(3),Ne=BigInt(4),Ue=BigInt(5),Te=BigInt(8);function M(t,n){const e=t%n;return e>=Y?e:n+e}function $(t,n,e){let r=t;for(;n-- >Y;)r*=r,r%=e;return r}function Gt(t,n){if(t===Y)throw new Error("invert: expected non-zero number");if(n<=Y)throw new Error("invert: expected positive modulus, got "+n);let e=M(t,n),r=n,s=Y,o=D,c=D,f=Y;for(;e!==Y;){const a=r/e,u=r%e,l=s-c*a,b=o-f*a;r=e,e=u,s=c,o=f,c=l,f=b}if(r!==D)throw new Error("invert: does not exist");return M(s,n)}function Re(t,n){const r=t.pow(n,(t.ORDER+D)/Ne);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function hn(t,n){const e=(t.ORDER-Ue)/Te,r=t.mul(n,gt),s=t.pow(r,e),o=t.mul(n,s),c=t.mul(t.mul(o,gt),s),f=t.mul(o,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}const wn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Le(t){return Ct(t,wn.reduce((r,s)=>(r[s]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function Wt(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),s=n.reduce((c,f,i)=>t.is0(f)?c:(r[i]=c,t.mul(c,f)),t.ONE),o=t.inv(s);return n.reduceRight((c,f,i)=>t.is0(f)?c:(r[i]=t.mul(c,r[i]),t.mul(c,f)),o),r}function te(t,n){const r=t.pow(n,(t.ORDER-D)/gt),s=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!s&&!o&&!c)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function ee(t,n){void 0!==n&&(0,R.Fe)(n);const e=void 0!==n?n:t.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}function jt(t,n,e=!1,r={}){if(t<=Y)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:o}=ee(t,n);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:o,MASK:zt(s),ZERO:Y,ONE:D,create:i=>M(i,t),isValid:i=>{if("bigint"!=typeof i)throw new Error("invalid field element: expected bigint, got "+typeof i);return Y<=i&&i<t},is0:i=>i===Y,isOdd:i=>(i&D)===D,neg:i=>M(-i,t),eql:(i,a)=>i===a,sqr:i=>M(i*i,t),add:(i,a)=>M(i+a,t),sub:(i,a)=>M(i-a,t),mul:(i,a)=>M(i*a,t),pow:(i,a)=>function ke(t,n,e){if(e<Y)throw new Error("invalid exponent, negatives unsupported");if(e===Y)return t.ONE;if(e===D)return n;let r=t.ONE,s=n;for(;e>Y;)e&D&&(r=t.mul(r,s)),s=t.sqr(s),e>>=D;return r}(f,i,a),div:(i,a)=>M(i*Gt(a,t),t),sqrN:i=>i*i,addN:(i,a)=>i+a,subN:(i,a)=>i-a,mulN:(i,a)=>i*a,inv:i=>Gt(i,t),sqrt:r.sqrt||(i=>(c||(c=function xn(t){return t%Ne===un?Re:t%Te===Ue?hn:function bn(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-D,e=0;for(;n%gt===Y;)n/=gt,e++;let r=gt;const s=jt(t);for(;1===te(s,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===e)return Re;let o=s.pow(r,n);const c=(n+D)/gt;return function(i,a){if(i.is0(a))return a;if(1!==te(i,a))throw new Error("Cannot find square root");let u=e,l=i.mul(i.ONE,o),b=i.pow(a,n),y=i.pow(a,c);for(;!i.eql(b,i.ONE);){if(i.is0(b))return i.ZERO;let p=1,h=i.sqr(b);for(;!i.eql(h,i.ONE);)if(p++,h=i.sqr(h),p===u)throw new Error("Cannot find square root");const N=D<<BigInt(u-p-1),_=i.pow(l,N);u=p,l=i.sqr(_),b=i.mul(b,l),y=i.mul(y,_)}return y}}(t)}(t)),c(f,i))),toBytes:i=>e?Oe(i,o):xt(i,o),fromBytes:i=>{if(i.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+i.length);return e?Ie(i):et(i)},invertBatch:i=>Wt(f,i),cmov:(i,a,u)=>u?a:i});return Object.freeze(f)}function Ze(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Ve(t){const n=Ze(t);return n+Math.ceil(n/2)}const De=BigInt(0),ne=BigInt(1);function re(t,n){const e=n.negate();return t?e:n}function se(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function oe(t,n){se(t,n);const s=2**t;return{windows:Math.ceil(n/t)+1,windowSize:2**(t-1),mask:zt(t),maxNumber:s,shiftBy:BigInt(t)}}function Me(t,n,e){const{windowSize:r,mask:s,maxNumber:o,shiftBy:c}=e;let f=Number(t&s),i=t>>c;f>r&&(f-=o,i+=ne);const a=n*r;return{nextN:i,offset:a+Math.abs(f)-1,isZero:0===f,isNeg:f<0,isNegF:n%2!=0,offsetF:a}}const ie=new WeakMap,Ge=new WeakMap;function ce(t){return Ge.get(t)||1}function yn(t,n,e,r){(function Pe(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})})(e,t),function ze(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}(r,n);const s=e.length,o=r.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,f=function an(t){let n;for(n=0;t>Pt;t>>=At,n+=1);return n}(BigInt(s));let i=1;f>12?i=f-3:f>4?i=f-2:f>0&&(i=2);const a=zt(i),u=new Array(Number(a)+1).fill(c);let b=c;for(let y=Math.floor((n.BITS-1)/i)*i;y>=0;y-=i){u.fill(c);for(let h=0;h<o;h++){const _=Number(r[h]>>BigInt(y)&a);u[_]=u[_].add(e[h])}let p=c;for(let h=u.length-1,N=c;h>0;h--)N=N.add(u[h]),p=p.add(N);if(b=b.add(p),0!==y)for(let h=0;h<i;h++)b=b.double()}return b}function We(t){return Le(t.Fp),Ct(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ee(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function je(t){void 0!==t.lowS&&_t("lowS",t.lowS),void 0!==t.prehash&&_t("prehash",t.prehash)}class pn extends Error{constructor(n=""){super(n)}}const rt={Err:pn,_tlv:{encode:(t,n)=>{const{Err:e}=rt;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(1&n.length)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=Ht(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const o=r>127?Ht(s.length/2|128):"";return Ht(t)+o+s+n},decode(t,n){const{Err:e}=rt;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++];let c=0;if(128&s){const i=127&s;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const a=n.subarray(r,r+i);if(a.length!==i)throw new e("tlv.decode: length bytes not complete");if(0===a[0])throw new e("tlv.decode(long): zero leftmost byte");for(const u of a)c=c<<8|u;if(r+=i,c<128)throw new e("tlv.decode(long): not minimal encoding")}else c=s;const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=rt;if(t<F)throw new n("integer: negative integers are not allowed");let e=Ht(t);if(8&Number.parseInt(e[0],16)&&(e="00"+e),1&e.length)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=rt;if(128&t[0])throw new n("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new n("invalid signature integer: unnecessary leading zero");return et(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=rt,s=z("signature",t),{v:o,l:c}=r.decode(48,s);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:i}=r.decode(2,o),{v:a,l:u}=r.decode(2,i);if(u.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(a)}},hexFromSig(t){const{_tlv:n,_int:e}=rt,r=n.encode(2,e.encode(t.r)),s=n.encode(2,e.encode(t.s));return n.encode(48,r+s)}};function fe(t,n){return It(xt(t,n))}const F=BigInt(0),Z=BigInt(1),dt=BigInt(2),Nt=BigInt(3),ae=BigInt(4);function An(t){const n=function vn(t){const n=We(t);return Ct(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}(t),{Fp:e,n:r,nByteLength:s,nBitLength:o}=n,c=e.BYTES+1,f=2*e.BYTES+1;function i(g){return M(g,r)}function a(g){return Gt(g,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:b,isWithinCurveOrder:y}=function Bn(t){const n=function En(t){const n=We(t);Ct(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof e||"bigint"!=typeof e.beta||"function"!=typeof e.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}(t),{Fp:e}=n,r=jt(n.n,n.nBitLength),s=n.toBytes||((x,d,m)=>{const E=d.toAffine();return J(Uint8Array.from([4]),e.toBytes(E.x),e.toBytes(E.y))}),o=n.fromBytes||(x=>{const d=x.subarray(1);return{x:e.fromBytes(d.subarray(0,e.BYTES)),y:e.fromBytes(d.subarray(e.BYTES,2*e.BYTES))}});function c(x){const{a:d,b:m}=n,E=e.sqr(x),v=e.mul(E,x);return e.add(e.add(v,e.mul(x,d)),m)}function f(x,d){const m=e.sqr(d),E=c(x);return e.eql(m,E)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const i=e.mul(e.pow(n.a,Nt),ae),a=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(i,a)))throw new Error("bad curve params: a or b");function l(x){const{allowedPrivateKeyLengths:d,nByteLength:m,wrapPrivateKey:E,n:v}=n;if(d&&"bigint"!=typeof x){if(St(x)&&(x=It(x)),"string"!=typeof x||!d.includes(x.length))throw new Error("invalid private key");x=x.padStart(2*m,"0")}let A;try{A="bigint"==typeof x?x:et(z("private key",x,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof x)}return E&&(A=M(A,v)),wt("private key",A,Z,v),A}function b(x){if(!(x instanceof h))throw new Error("ProjectivePoint expected")}const y=Ce((x,d)=>{const{px:m,py:E,pz:v}=x;if(e.eql(v,e.ONE))return{x:m,y:E};const A=x.is0();null==d&&(d=A?e.ONE:e.inv(v));const q=e.mul(m,d),k=e.mul(E,d),S=e.mul(v,d);if(A)return{x:e.ZERO,y:e.ZERO};if(!e.eql(S,e.ONE))throw new Error("invZ was invalid");return{x:q,y:k}}),p=Ce(x=>{if(x.is0()){if(n.allowInfinityPoint&&!e.is0(x.py))return;throw new Error("bad point: ZERO")}const{x:d,y:m}=x.toAffine();if(!e.isValid(d)||!e.isValid(m))throw new Error("bad point: x or y not FE");if(!f(d,m))throw new Error("bad point: equation left != right");if(!x.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(d,m,E){if(null==d||!e.isValid(d))throw new Error("x required");if(null==m||!e.isValid(m)||e.is0(m))throw new Error("y required");if(null==E||!e.isValid(E))throw new Error("z required");this.px=d,this.py=m,this.pz=E,Object.freeze(this)}static fromAffine(d){const{x:m,y:E}=d||{};if(!d||!e.isValid(m)||!e.isValid(E))throw new Error("invalid affine point");if(d instanceof h)throw new Error("projective point not allowed");const v=A=>e.eql(A,e.ZERO);return v(m)&&v(E)?h.ZERO:new h(m,E,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const m=Wt(e,d.map(E=>E.pz));return d.map((E,v)=>E.toAffine(m[v])).map(h.fromAffine)}static fromHex(d){const m=h.fromAffine(o(z("pointHex",d)));return m.assertValidity(),m}static fromPrivateKey(d){return h.BASE.multiply(l(d))}static msm(d,m){return yn(h,r,d,m)}_setWindowSize(d){L.setWindowSize(this,d)}assertValidity(){p(this)}hasEvenY(){const{y:d}=this.toAffine();if(e.isOdd)return!e.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){b(d);const{px:m,py:E,pz:v}=this,{px:A,py:q,pz:k}=d,S=e.eql(e.mul(m,k),e.mul(A,v)),C=e.eql(e.mul(E,k),e.mul(q,v));return S&&C}negate(){return new h(this.px,e.neg(this.py),this.pz)}double(){const{a:d,b:m}=n,E=e.mul(m,Nt),{px:v,py:A,pz:q}=this;let k=e.ZERO,S=e.ZERO,C=e.ZERO,H=e.mul(v,v),P=e.mul(A,A),g=e.mul(q,q),w=e.mul(v,A);return w=e.add(w,w),C=e.mul(v,q),C=e.add(C,C),k=e.mul(d,C),S=e.mul(E,g),S=e.add(k,S),k=e.sub(P,S),S=e.add(P,S),S=e.mul(k,S),k=e.mul(w,k),C=e.mul(E,C),g=e.mul(d,g),w=e.sub(H,g),w=e.mul(d,w),w=e.add(w,C),C=e.add(H,H),H=e.add(C,H),H=e.add(H,g),H=e.mul(H,w),S=e.add(S,H),g=e.mul(A,q),g=e.add(g,g),H=e.mul(g,w),k=e.sub(k,H),C=e.mul(g,P),C=e.add(C,C),C=e.add(C,C),new h(k,S,C)}add(d){b(d);const{px:m,py:E,pz:v}=this,{px:A,py:q,pz:k}=d;let S=e.ZERO,C=e.ZERO,H=e.ZERO;const P=n.a,g=e.mul(n.b,Nt);let w=e.mul(m,A),B=e.mul(E,q),T=e.mul(v,k),I=e.add(m,E),U=e.add(A,q);I=e.mul(I,U),U=e.add(w,B),I=e.sub(I,U),U=e.add(m,v);let V=e.add(A,k);return U=e.mul(U,V),V=e.add(w,T),U=e.sub(U,V),V=e.add(E,v),S=e.add(q,k),V=e.mul(V,S),S=e.add(B,T),V=e.sub(V,S),H=e.mul(P,U),S=e.mul(g,T),H=e.add(S,H),S=e.sub(B,H),H=e.add(B,H),C=e.mul(S,H),B=e.add(w,w),B=e.add(B,w),T=e.mul(P,T),U=e.mul(g,U),B=e.add(B,T),T=e.sub(w,T),T=e.mul(P,T),U=e.add(U,T),w=e.mul(B,U),C=e.add(C,w),w=e.mul(V,U),S=e.mul(I,S),S=e.sub(S,w),w=e.mul(I,B),H=e.mul(V,H),H=e.add(H,w),new h(S,C,H)}subtract(d){return this.add(d.negate())}is0(){return this.equals(h.ZERO)}wNAF(d){return L.wNAFCached(this,d,h.normalizeZ)}multiplyUnsafe(d){const{endo:m,n:E}=n;wt("scalar",d,F,E);const v=h.ZERO;if(d===F)return v;if(this.is0()||d===Z)return this;if(!m||L.hasPrecomputes(this))return L.wNAFCachedUnsafe(this,d,h.normalizeZ);let{k1neg:A,k1:q,k2neg:k,k2:S}=m.splitScalar(d),C=v,H=v,P=this;for(;q>F||S>F;)q&Z&&(C=C.add(P)),S&Z&&(H=H.add(P)),P=P.double(),q>>=Z,S>>=Z;return A&&(C=C.negate()),k&&(H=H.negate()),H=new h(e.mul(H.px,m.beta),H.py,H.pz),C.add(H)}multiply(d){const{endo:m,n:E}=n;let v,A;if(wt("scalar",d,Z,E),m){const{k1neg:q,k1:k,k2neg:S,k2:C}=m.splitScalar(d);let{p:H,f:P}=this.wNAF(k),{p:g,f:w}=this.wNAF(C);H=L.constTimeNegate(q,H),g=L.constTimeNegate(S,g),g=new h(e.mul(g.px,m.beta),g.py,g.pz),v=H.add(g),A=P.add(w)}else{const{p:q,f:k}=this.wNAF(d);v=q,A=k}return h.normalizeZ([v,A])[0]}multiplyAndAddUnsafe(d,m,E){const v=h.BASE,A=(k,S)=>S!==F&&S!==Z&&k.equals(v)?k.multiply(S):k.multiplyUnsafe(S),q=A(this,m).add(A(d,E));return q.is0()?void 0:q}toAffine(d){return y(this,d)}isTorsionFree(){const{h:d,isTorsionFree:m}=n;if(d===Z)return!0;if(m)return m(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:m}=n;return d===Z?this:m?m(h,this):this.multiplyUnsafe(n.h)}toRawBytes(d=!0){return _t("isCompressed",d),this.assertValidity(),s(h,this,d)}toHex(d=!0){return _t("isCompressed",d),It(this.toRawBytes(d))}}h.BASE=new h(n.Gx,n.Gy,e.ONE),h.ZERO=new h(e.ZERO,e.ONE,e.ZERO);const{endo:N,nBitLength:_}=n,L=function mn(t,n){return{constTimeNegate:re,hasPrecomputes:e=>1!==ce(e),unsafeLadder(e,r,s=t.ZERO){let o=e;for(;r>De;)r&ne&&(s=s.add(o)),o=o.double(),r>>=ne;return s},precomputeWindow(e,r){const{windows:s,windowSize:o}=oe(r,n),c=[];let f=e,i=f;for(let a=0;a<s;a++){i=f,c.push(i);for(let u=1;u<o;u++)i=i.add(f),c.push(i);f=i.double()}return c},wNAF(e,r,s){let o=t.ZERO,c=t.BASE;const f=oe(e,n);for(let i=0;i<f.windows;i++){const{nextN:a,offset:u,isZero:l,isNeg:b,isNegF:y,offsetF:p}=Me(s,i,f);s=a,l?c=c.add(re(y,r[p])):o=o.add(re(b,r[u]))}return{p:o,f:c}},wNAFUnsafe(e,r,s,o=t.ZERO){const c=oe(e,n);for(let f=0;f<c.windows&&s!==De;f++){const{nextN:i,offset:a,isZero:u,isNeg:l}=Me(s,f,c);if(s=i,!u){const b=r[a];o=o.add(l?b.negate():b)}}return o},getPrecomputes(e,r,s){let o=ie.get(r);return o||(o=this.precomputeWindow(r,e),1!==e&&ie.set(r,s(o))),o},wNAFCached(e,r,s){const o=ce(e);return this.wNAF(o,this.getPrecomputes(o,e,s),r)},wNAFCachedUnsafe(e,r,s,o){const c=ce(e);return 1===c?this.unsafeLadder(e,r,o):this.wNAFUnsafe(c,this.getPrecomputes(c,e,s),r,o)},setWindowSize(e,r){se(r,n),Ge.set(e,r),ie.delete(e)}}}(h,N?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:h,normPrivateKeyToScalar:l,weierstrassEquation:c,isWithinCurveOrder:function u(x){return qt(x,Z,n.n)}}}({...n,toBytes(g,w,B){const T=w.toAffine(),I=e.toBytes(T.x),U=J;return _t("isCompressed",B),B?U(Uint8Array.from([w.hasEvenY()?2:3]),I):U(Uint8Array.from([4]),I,e.toBytes(T.y))},fromBytes(g){const w=g.length,B=g[0],T=g.subarray(1);if(w!==c||2!==B&&3!==B){if(w===f&&4===B)return{x:e.fromBytes(T.subarray(0,e.BYTES)),y:e.fromBytes(T.subarray(e.BYTES,2*e.BYTES))};throw new Error("invalid Point, expected length of "+c+", or uncompressed "+f+", got "+w)}{const I=et(T);if(!qt(I,Z,e.ORDER))throw new Error("Point is not on curve");const U=b(I);let V;try{V=e.sqrt(U)}catch(tt){const X=tt instanceof Error?": "+tt.message:"";throw new Error("Point is not on curve"+X)}return!(1&~B)!=((V&Z)===Z)&&(V=e.neg(V)),{x:I,y:V}}}});function p(g){return g>r>>Z}const N=(g,w,B)=>et(g.slice(w,B));class _{constructor(w,B,T){wt("r",w,Z,r),wt("s",B,Z,r),this.r=w,this.s=B,null!=T&&(this.recovery=T),Object.freeze(this)}static fromCompact(w){const B=s;return w=z("compactSignature",w,2*B),new _(N(w,0,B),N(w,B,2*B))}static fromDER(w){const{r:B,s:T}=rt.toSig(z("DER",w));return new _(B,T)}assertValidity(){}addRecoveryBit(w){return new _(this.r,this.s,w)}recoverPublicKey(w){const{r:B,s:T,recovery:I}=this,U=v(z("msgHash",w));if(null==I||![0,1,2,3].includes(I))throw new Error("recovery id invalid");const V=2===I||3===I?B+n.n:B;if(V>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const st=u.fromHex((1&I?"03":"02")+fe(V,e.BYTES)),tt=a(V),X=i(-U*tt),pt=i(T*tt),bt=u.BASE.multiplyAndAddUnsafe(st,X,pt);if(!bt)throw new Error("point at infinify");return bt.assertValidity(),bt}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return Ot(this.toDERHex())}toDERHex(){return rt.hexFromSig(this)}toCompactRawBytes(){return Ot(this.toCompactHex())}toCompactHex(){const w=s;return fe(this.r,w)+fe(this.s,w)}}const L={isValidPrivateKey(g){try{return l(g),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const g=Ve(n.n);return function gn(t,n,e=!1){const r=t.length,s=Ze(n),o=Ve(n);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const f=M(e?Ie(t):et(t),n-D)+D;return e?Oe(f,s):xt(f,s)}(n.randomBytes(g),n.n)},precompute:(g=8,w=u.BASE)=>(w._setWindowSize(g),w.multiply(BigInt(3)),w)};function d(g){if("bigint"==typeof g)return!1;if(g instanceof u)return!0;const B=z("key",g).length,T=e.BYTES,I=T+1;return n.allowedPrivateKeyLengths||s===I?void 0:B===I||B===2*T+1}const E=n.bits2int||function(g){if(g.length>8192)throw new Error("input is too large");const w=et(g),B=8*g.length-o;return B>0?w>>BigInt(B):w},v=n.bits2int_modN||function(g){return i(E(g))},A=zt(o);function q(g){return wt("num < 2^"+o,g,F,A),xt(g,s)}const S={lowS:n.lowS,prehash:!1},C={lowS:n.lowS,prehash:!1};return u.BASE._setWindowSize(8),{CURVE:n,getPublicKey:function x(g,w=!0){return u.fromPrivateKey(g).toRawBytes(w)},getSharedSecret:function m(g,w,B=!0){if(!0===d(g))throw new Error("first arg must be private key");if(!1===d(w))throw new Error("second arg must be public key");return u.fromHex(w).multiply(l(g)).toRawBytes(B)},sign:function H(g,w,B=S){const{seed:T,k2sig:I}=function k(g,w,B=S){if(["recovered","canonical"].some(mt=>mt in B))throw new Error("sign() legacy options not supported");const{hash:T,randomBytes:I}=n;let{lowS:U,prehash:V,extraEntropy:Q}=B;null==U&&(U=!0),g=z("msgHash",g),je(B),V&&(g=z("prehashed msgHash",T(g)));const st=v(g),tt=l(w),X=[q(tt),q(st)];if(null!=Q&&!1!==Q){const mt=!0===Q?I(e.BYTES):Q;X.push(z("extraEntropy",mt))}const pt=J(...X),bt=st;return{seed:pt,k2sig:function ge(mt){const Bt=E(mt);if(!y(Bt))return;const me=a(Bt),Zt=u.BASE.multiply(Bt).toAffine(),yt=i(Zt.x);if(yt===F)return;const Vt=i(me*i(bt+yt*tt));if(Vt===F)return;let vt=(Zt.x===yt?0:2)|Number(Zt.y&Z),tn=Vt;return U&&p(Vt)&&(tn=function h(g){return p(g)?i(-g):g}(Vt),vt^=1),new _(yt,tn,vt)}}}(g,w,B);return function ln(t,n,e){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof n||n<2)throw new Error("qByteLen must be a number");if("function"!=typeof e)throw new Error("hmacFn must be a function");let r=Ft(t),s=Ft(t),o=0;const c=()=>{r.fill(1),s.fill(0),o=0},f=(...l)=>e(s,r,...l),i=(l=Ft(0))=>{s=f(qe([0]),l),r=f(),0!==l.length&&(s=f(qe([1]),l),r=f())},a=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const b=[];for(;l<n;){r=f();const y=r.slice();b.push(y),l+=r.length}return J(...b)};return(l,b)=>{let y;for(c(),i(l);!(y=b(a()));)i();return c(),y}}(n.hash.outputLen,n.nByteLength,n.hmac)(T,I)},verify:function P(g,w,B,T=C){const I=g;w=z("msgHash",w),B=z("publicKey",B);const{lowS:U,prehash:V,format:Q}=T;if(je(T),"strict"in T)throw new Error("options.strict was renamed to lowS");if(void 0!==Q&&"compact"!==Q&&"der"!==Q)throw new Error("format must be compact or der");const st="string"==typeof I||St(I),tt=!st&&!Q&&"object"==typeof I&&null!==I&&"bigint"==typeof I.r&&"bigint"==typeof I.s;if(!st&&!tt)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let X,pt;try{if(tt&&(X=new _(I.r,I.s)),st){try{"compact"!==Q&&(X=_.fromDER(I))}catch(vt){if(!(vt instanceof rt.Err))throw vt}!X&&"der"!==Q&&(X=_.fromCompact(I))}pt=u.fromHex(B)}catch{return!1}if(!X||U&&X.hasHighS())return!1;V&&(w=n.hash(w));const{r:bt,s:ge}=X,mt=v(w),Bt=a(ge),me=i(mt*Bt),Zt=i(bt*Bt),yt=u.BASE.multiplyAndAddUnsafe(pt,me,Zt)?.toAffine();return!!yt&&i(yt.x)===bt},ProjectivePoint:u,Signature:_,utils:L}}function Hn(t){return{hash:t,hmac:(n,...e)=>Ae(t,n,(0,R.Id)(...e)),randomBytes:R.po}}const On=et;function ut(t,n){if(Ut(t),Ut(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=255&t,t>>>=8;return new Uint8Array(e)}function qn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Ut(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Ke(t,n,e){Ct(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:o,hash:c,expand:f,DST:i}=e;lt(t),Ut(n);const a="string"==typeof i?Jt(i):i,u=r.toString(2).length,l=Math.ceil((u+s)/8),b=n*o*l;let y;if("xmd"===f)y=function Cn(t,n,e,r){lt(t),lt(n),Ut(e),n.length>255&&(n=r(J(Jt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:o}=r,c=Math.ceil(e/s);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=J(n,ut(n.length,1)),i=ut(0,o),a=ut(e,2),u=new Array(c),l=r(J(i,t,a,ut(0,1),f));u[0]=r(J(l,ut(1,1),f));for(let y=1;y<=c;y++){const p=[qn(l,u[y-1]),ut(y+1,1),f];u[y]=r(J(...p))}return J(...u).slice(0,e)}(t,a,b,c);else if("xof"===f)y=function Nn(t,n,e,r,s){if(lt(t),lt(n),Ut(e),n.length>255){const o=Math.ceil(2*r/8);n=s.create({dkLen:o}).update(Jt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(ut(e,2)).update(n).update(ut(n.length,1)).digest()}(t,a,b,s,c);else{if("_internal_pass"!==f)throw new Error('expand must be "xmd" or "xof"');y=t}const p=new Array(n);for(let h=0;h<n;h++){const N=new Array(o);for(let _=0;_<o;_++){const L=l*(_+h*o),x=y.subarray(L,L+l);N[_]=M(On(x),r)}p[h]=N}return p}const Tt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Kt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),le=BigInt(0),Rt=BigInt(1),Yt=BigInt(2),Ye=(t,n)=>(t+n/Yt)/n;function Qe(t){const n=Tt,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),c=BigInt(23),f=BigInt(44),i=BigInt(88),a=t*t*t%n,u=a*a*t%n,l=$(u,e,n)*u%n,b=$(l,e,n)*u%n,y=$(b,Yt,n)*a%n,p=$(y,s,n)*y%n,h=$(p,o,n)*p%n,N=$(h,f,n)*h%n,_=$(N,i,n)*N%n,L=$(_,f,n)*h%n,x=$(L,e,n)*u%n,d=$(x,c,n)*p%n,m=$(d,r,n)*a%n,E=$(m,Yt,n);if(!ht.eql(ht.sqr(E),t))throw new Error("Cannot find square root");return E}const ht=jt(Tt,void 0,void 0,{sqrt:Qe}),Lt=function In(t,n){const e=r=>An({...t,...Hn(r)});return{...e(n),create:e}}({a:le,b:BigInt(7),Fp:ht,n:Kt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Kt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Rt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,c=BigInt("0x100000000000000000000000000000000"),f=Ye(o*t,n),i=Ye(-r*t,n);let a=M(t-f*e-i*s,n),u=M(-f*r-i*o,n);const l=a>c,b=u>c;if(l&&(a=n-a),b&&(u=n-u),a>c||u>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:a,k2neg:b,k2:u}}}},Mt),Xe={};function Qt(t,...n){let e=Xe[t];if(void 0===e){const r=Mt(Uint8Array.from(t,s=>s.charCodeAt(0)));e=J(r,r),Xe[t]=e}return Mt(J(e,...n))}const de=t=>t.toRawBytes(!0).slice(1),ue=t=>xt(t,32),he=t=>M(t,Tt),kt=t=>M(t,Kt),be=Lt.ProjectivePoint;function xe(t){let n=Lt.utils.normPrivateKeyToScalar(t),e=be.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:kt(-n),bytes:de(e)}}function Je(t){wt("x",t,Rt,Tt);const n=he(t*t);let r=Qe(he(n*t+BigInt(7)));r%Yt!==le&&(r=he(-r));const s=new be(t,r,Rt);return s.assertValidity(),s}const Et=et;function $e(...t){return kt(Et(Qt("BIP0340/challenge",...t)))}function Fe(t,n,e){const r=z("signature",t,64),s=z("message",n),o=z("publicKey",e,32);try{const c=Je(Et(o)),f=Et(r.subarray(0,32));if(!qt(f,Rt,Tt))return!1;const i=Et(r.subarray(32,64));if(!qt(i,Rt,Kt))return!1;const a=$e(ue(f),de(c),s),u=((t,n,e)=>be.BASE.multiplyAndAddUnsafe(t,n,e))(c,i,kt(-a));return!(!u||!u.hasEvenY()||u.toAffine().x!==f)}catch{return!1}}const Zn={getPublicKey:function Ln(t){return xe(t).bytes},sign:function kn(t,n,e=(0,R.po)(32)){const r=z("message",t),{bytes:s,scalar:o}=xe(n),c=z("auxRand",e,32),f=ue(o^Et(Qt("BIP0340/aux",c))),i=Qt("BIP0340/nonce",f,s,r),a=kt(Et(i));if(a===le)throw new Error("sign failed: k is zero");const{bytes:u,scalar:l}=xe(a),b=$e(u,s,r),y=new Uint8Array(64);if(y.set(u,0),y.set(ue(kt(l+b*o)),32),!Fe(y,r,s))throw new Error("sign: Invalid signature produced");return y},verify:Fe,utils:{randomPrivateKey:Lt.utils.randomPrivateKey,lift_x:Je,pointToBytes:de,numberToBytesBE:xt,bytesToNumberBE:et,taggedHash:Qt,mod:M}},Vn=function Un(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[o,c,f,i]=e.map(l=>l.reduce((b,y)=>t.add(t.mul(b,r),y))),[a,u]=Wt(t,[c,i],!0);return r=t.mul(o,a),s=t.mul(s,t.mul(f,u)),{x:r,y:s}}}(ht,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),Dn=function _n(t,n){if(Le(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=function Sn(t,n){const e=t.ORDER;let r=F;for(let p=e-Z;p%dt===F;p/=dt)r+=Z;const s=r,o=dt<<s-Z-Z,c=o*dt,f=(e-Z)/c,i=(f-Z)/dt,a=c-Z,u=o,l=t.pow(n,f),b=t.pow(n,(f+Z)/dt);let y=(p,h)=>{let N=l,_=t.pow(h,a),L=t.sqr(_);L=t.mul(L,h);let x=t.mul(p,L);x=t.pow(x,i),x=t.mul(x,_),_=t.mul(x,h),L=t.mul(x,p);let d=t.mul(L,_);x=t.pow(d,u);let m=t.eql(x,t.ONE);_=t.mul(L,b),x=t.mul(d,N),L=t.cmov(_,L,m),d=t.cmov(x,d,m);for(let E=s;E>Z;E--){let v=E-dt;v=dt<<v-Z;let A=t.pow(d,v);const q=t.eql(A,t.ONE);_=t.mul(L,N),N=t.mul(N,N),A=t.mul(d,N),L=t.cmov(_,L,q),d=t.cmov(A,d,q)}return{isValid:m,value:L}};if(t.ORDER%ae===Nt){const p=(t.ORDER-Nt)/ae,h=t.sqrt(t.neg(n));y=(N,_)=>{let L=t.sqr(_);const x=t.mul(N,_);L=t.mul(L,x);let d=t.pow(L,p);d=t.mul(d,x);const m=t.mul(d,h),E=t.mul(t.sqr(d),_),v=t.eql(E,N);return{isValid:v,value:t.cmov(m,d,v)}}}return y}(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,o,c,f,i,a,u,l;s=t.sqr(r),s=t.mul(s,n.Z),o=t.sqr(s),o=t.add(o,s),c=t.add(o,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(o),!t.eql(o,t.ZERO)),f=t.mul(f,n.A),o=t.sqr(c),a=t.sqr(f),i=t.mul(a,n.A),o=t.add(o,i),o=t.mul(o,c),a=t.mul(a,f),i=t.mul(a,n.B),o=t.add(o,i),u=t.mul(s,c);const{isValid:b,value:y}=e(o,a);l=t.mul(s,r),l=t.mul(l,y),u=t.cmov(u,c,b),l=t.cmov(l,y,b);const p=t.isOdd(r)===t.isOdd(l);l=t.cmov(t.neg(l),l,p);const h=Wt(t,[f],!0)[0];return u=t.mul(u,h),{x:u,y:l}}}(ht,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ht.create(BigInt("-11"))}),we=function Tn(t,n,e){if("function"!=typeof n)throw new Error("mapToCurve() must be defined");function r(o){return t.fromAffine(n(o))}function s(o){const c=o.clearCofactor();return c.equals(t.ZERO)?t.ZERO:(c.assertValidity(),c)}return{defaults:e,hashToCurve(o,c){const f=Ke(o,2,{...e,DST:e.DST,...c}),i=r(f[0]),a=r(f[1]);return s(i.add(a))},encodeToCurve:(o,c)=>s(r(Ke(o,1,{...e,DST:e.encodeDST,...c})[0])),mapToCurve(o){if(!Array.isArray(o))throw new Error("expected array of bigints");for(const c of o)if("bigint"!=typeof c)throw new Error("expected array of bigints");return s(r(o))}}}(Lt.ProjectivePoint,t=>{const{x:n,y:e}=Dn(ht.create(t[0]));return Vn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ht.ORDER,m:1,k:128,expand:"xmd",hash:Mt}),Mn=we.hashToCurve,Pn=we.encodeToCurve}}]);